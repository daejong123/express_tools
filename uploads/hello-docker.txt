Docker 是一种“轻量级”容器技术
Docker 的名词术语：容器、镜像等

Dockerfile文件和核心指令： http://dockone.io/article/5998

1.凡是使用过虚拟机的同学，应该都知道，启动虚拟机就像启动一台计算机，初始化过程是相当慢的，我们需要等很久，才能看到登录界面,一旦虚拟机启动以后，就可以与宿主机建立网络连接，确保虚拟机与宿主机之间是互联互通的。不同的虚拟机之间却是相互隔离的，也就是说，彼此并不知道对方的存在，但每个虚拟机占用的都是宿主机的硬件与网络资源。

2.在宿主机的操作系统上，有一个 Docker 服务在运行（或者称为“Docker 引擎”），在此服务上，我们可开启多个 Docker 容器，而每个 Docker 容器中可运行自己所需的应用程序，Docker 容器之间也是相互隔离的，同样地，都是占用的宿主机的硬件与网络资源。
Docker 容器相对于虚拟机而言，除了在技术实现上完全不一样以外，启动速度较虚拟机而言有本质的飞跃，启动一个容器只在眨眼瞬间。不管是虚拟机还是 Docker 容器，它们都是为了隔离应用程序的运行环境，节省我们的硬件资源，为我们开发人员提供福利。

3.这是一只鲸鱼，它托着许多集装箱。我们可以把宿主机可当做这只鲸鱼，把相互隔离的容器可看成集装箱，每个集装箱中都包含自己的应用程序。这 Logo 简直的太形象了！



docker info 查看信息
docker ps -a 查看容器情况 docker rm cid 删除容器  docker stop cid停止容器
docker images 查看本机镜像 docker rmi iid
docker run ubuntu:15.10 /bin/echo 'helo' 指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。
docker run centos 会去下载centos,如果没有命令，则不运行。
docker pull centos 载入一个镜像

docker pull training/webapp  # 载入镜像
docker run -d -P training/webapp python app.py 
-d:让容器在后台运行。
-P:将容器内部使用的网络端口映射到我们使用的主机上。
-t:在容器内开一个终端
-i:可以和容器交互


docker seach image 从 Docker Hub 网站来搜索镜像


我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。
cat Dockerfile 

FROM    centos:6.7
MAINTAINER      Fisher "fisher@sudops.com"

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e "LANG=\"en_US.UTF-8\"" >/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D

每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。

第一条FROM，指定使用哪个镜像源

RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。

然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。

docker build -t runoob/centos:6.7 .
-t ：指定要创建的目标镜像名
. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径


使用docker images 查看创建的镜像已经在列表中存在,
我们可以使用新的镜像来创建容器
docker run -t -i runoob/centos:6.7  /bin/bash



-P :是容器内部端口随机映射到主机的高端口。
-p : 是容器内部端口绑定到指定的主机端口。


docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  
命令说明：

-p 80:80：将容器的80端口映射到主机的80端口

--name mynginx：将容器命名为mynginx

-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www

-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf

-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs



===============================================================================================================


创建一个Dockerfile，用来创建镜像。

通过 Dockerfile 创建一个镜像，替换成你自己的名字。
docker build -t nginx .


通过docker images 查看我们刚刚创建的镜像
docker images

通过docker run 运行容器
docker run 
	-p 80:80  端口映射（宿主机:container）
	--name mynginx  创建的容器别名
	-v $PWD/www:/www 宿主机文件目录映射到container中的目录
	-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf 
	-d nginx  以守护进程运行(后台运行容器，并返回容器ID)， 使用的镜像名称。

-i：表示以“交互模式”运行容器
-t：表示容器启动后会进入其命令行
-v：表示需要将本地哪个目录挂载到容器中，格式：-v <宿主机目录>:<容器目录>


docker run 参数：
-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；
-d: 后台运行容器，并返回容器ID；
-i: 以交互模式运行容器，通常与 -t 同时使用；
-p: 端口映射，格式为：主机(宿主)端口:容器端口
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--name="nginx-lb": 为容器指定一个名称；
--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
-h "mars": 指定容器的hostname；
-e username="ritchie": 设置环境变量；
--env-file=[]: 从指定文件读入环境变量；
--cpuset="0-2" or --cpuset="0,1,2": 绑定容器到指定CPU运行；
-m :设置容器使用内存最大值；
--net="bridge": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
--link=[]: 添加链接到另一个容器；
--expose=[]: 开放一个端口或一组端口；


如：
使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。
docker run -it nginx:latest /bin/bash

使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。
docker run --name mynginx -d nginx:latest

使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。
docker run -p 80:80 -v /data:/data -d nginx:latest



Dockerfile制作镜像：
1.主要就是基于需要的基础镜像，在该基础镜像中添加自己的配置(如jdk，tomcat等等配置)以及利用该镜像启动容器时自执行命令，暴露端口。成为我们所需要的的镜像。
2. docker build -t myImageName .
3. docker images查看
4. docker run -d -p 8080:8080 myImageName
 

将jar包制作成docker镜像
1、准备可运行jar包
2、建立Dockerfile文件
文件内容：
FROM java:8
ADD api-gateway-microservice-0.1.0.jar app.jar
RUN bash -c 'touch /app.jar'
ENTRYPOINT ["java","-jar","/app.jar"]

1、FROM
格式：FROM <image>或 FROM <image>:<tag>
定义基础镜像，后面的RUN是在此基础上运行。第一条指令必须为FROM指令，并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）

2、ADD
格式：ADD  <src>  <dest>

定义变量吧。复制指定的<src>到容器的<dest>中，<src>可以是Dockerfile所在的目录的一个相对路径；可以是URL，也可以是tar.gz（自动解压）
注意与你的文件名一致

3、RUN
格式：RUN <command> 或 RUN ["", "", ""]
每条指令将在当前镜像基础上执行，并提交为新的镜像。（可以用“\”换行）




例子：
比如我们我要运行一个tomcat容器。
1. docker search tomcat
2. docker pull tomcat
3. docker images 查看
4. docker run -p 8081:8080 --name tomcat-test tomcat 这样直接前台运行了。(也可以用-d 在后台运行，即作为守护进程)
5. 最后，在宿主机上直接访问 localhost:8081就可以访问了。

6. docker stop cid.
7. 如果想启动一个已经exit的容器， 使用 docker start container_name(或者cid)； 就会以守护进程在后台运行, 
   docker start container_name -i (交互启动，即前台运行,表示以“交互模式”运行容器）
8. Docker restart cid

启动容器时，指定参数启动一个bash交互终端
docker run -it imageName /bin/bash



Hello-world例子
1. 安装docker ： yum -y install docker-io
2. 启动docker： service docker start
3. 查看是否启动成功： docker version 
4. 修改镜像配置(加速)： /etc/docker/daemon.json :  "registry-mirrors": ["http://hub-mirror.c.163.com"]
5. pull镜像hello-world： docker pull hello-world （可以先docker search hello-world）
6. 根据镜像启动容器： docker run hello-world
7. 可以看到输出信息
   Hello from Docker!
   This message shows that your installation appears to be working correctly.



